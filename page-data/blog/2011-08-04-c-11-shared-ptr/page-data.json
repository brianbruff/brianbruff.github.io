{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/2011-08-04-c-11-shared-ptr/","result":{"data":{"markdownRemark":{"html":"<p>To be honest, it’s been a long time since I did any real c++, however I’ve been reading a Java book lately and it’s made me kinda lonesome for C++, the Java book goes into a lot of detail about core language structure, it’s not a book on hibernate, swing etc, just core fundamentals like differences between an internal private class or an internal private interface, static binding of fields etc. I remember when I was at the height of my c++ development career I knew the intricacies about default parameters being statically bound in polymorphic classes, I knew about private inheritance, pitfalls of overriding non virtual functions, thinking back I knew the language quite intimately. Sure in the .net world I know quite a lot of the framework and the libraries toolsets etc (because i’m a greedy little pig and want to know everything) but, I wonder do i know the c# language quite as well as I once knew c++.</p>\n<p>As I said at the outset I’ve been away from c++ for a few years now, I think the last time I did any commercial c++ was in 2006 when I was up to my eyeballs in boost/stl/wtl/atl etc, so what’s changed? Well there’s a new standard for one, <strong>C++11</strong>. Just to keep my finger in I’ve decided to start writing a few little blog posts on the new standard, this is the first one.</p>\n<p>In Boost we used to used shared_ptr this class template stored a pointer to a dynamically allocated object, the object pointed to was guaranteed to be deleted when the last shared_ptr pointing to it was destroyed or reset.</p>\n<p>e.g.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">#include \n\n#include \n\n#include \n\n#include \n\n#include \n\n//  The application will produce a series of\n\n//  objects of type Foo which later must be\n\n//  accessed both by occurrence (std::vector)\n\n//  and by ordering relationship (std::set).\n\nstruct Foo\n\n{ \n\n  Foo( int _x ) : x(_x) {}\n\n  ~Foo() { std::cout &lt;&lt; \"Destructing a Foo with x=\" &lt;&lt; x &lt;&lt; \"\\n\"; }\n\n  int x;\n\n  /* ... */\n\n};\n\ntypedef boost::shared_ptr FooPtr;\n\nstruct FooPtrOps\n\n{\n\n  bool operator()( const FooPtr &amp; a, const FooPtr &amp; b )\n\n    { return a->x > b->x; }\n\n  void operator()( const FooPtr &amp; a )\n\n    { std::cout &lt;&lt; a->x &lt;&lt; \"\\n\"; }\n\n};\n\nint main()\n\n{\n\n  std::vector         foo_vector;\n\n  std::set  foo_set; // NOT multiset!\n\n  FooPtr foo_ptr( new Foo( 2 ) );\n\n  foo_vector.push_back( foo_ptr );\n\n  foo_set.insert( foo_ptr );\n\n  foo_ptr.reset( new Foo( 1 ) );\n\n  foo_vector.push_back( foo_ptr );\n\n  foo_set.insert( foo_ptr );\n\n  foo_ptr.reset( new Foo( 3 ) );\n\n  foo_vector.push_back( foo_ptr );\n\n  foo_set.insert( foo_ptr );\n\n  foo_ptr.reset ( new Foo( 2 ) );\n\n  foo_vector.push_back( foo_ptr );\n\n  foo_set.insert( foo_ptr );\n\n  std::cout &lt;&lt; \"foo_vector:\\n\";\n\n  std::for_each( foo_vector.begin(), foo_vector.end(), FooPtrOps() );\n\n  std::cout &lt;&lt; \"\\nfoo_set:\\n\"; \n\n  std::for_each( foo_set.begin(), foo_set.end(), FooPtrOps() );\n\n  std::cout &lt;&lt; \"\\n\";\n\n//  Expected output:\n\n//\n\n//   foo_vector:\n\n//   2\n\n//   1\n\n//   3\n\n//   2\n\n//   \n\n//   foo_set:\n\n//   3\n\n//   2\n\n//   1\n\n//\n\n//   Destructing a Foo with x=2\n\n//   Destructing a Foo with x=1\n\n//   Destructing a Foo with x=3\n\n//   Destructing a Foo with x=2\n\n  return 0;\n\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>In c++ 11 we now get a shared pointer as part of the standard, see my example below.</p>\n<p><img src=\"/images//blog/image.axd?picture=image_thumb_74.png\" alt=\"\"></p>\n<p>I know there were some overheads to the boost shared pointer, memory footprint etc, (consider 1x106). of these guys in a container!. But in general shared_ptr can help you, because if you do it manually you’ll likely write slower, buggier code (or both).</p>","frontmatter":{"title":"C++ 11–shared_ptr","date":"August 04, 2011"}}},"pageContext":{"slug":"/blog/2011-08-04-c-11-shared-ptr/"}},"staticQueryHashes":["2326376460","63159454"],"slicesMap":{}}