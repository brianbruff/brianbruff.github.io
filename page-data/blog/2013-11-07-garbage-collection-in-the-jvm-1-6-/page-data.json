{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/2013-11-07-garbage-collection-in-the-jvm-1-6-/","result":{"data":{"markdownRemark":{"html":"<p>Hi guys,</p>\n<p>I’ve found myself discussing garbage collecting in the JVM a few times this week and though I’d share this information with everyone that ever wondered how all this works.</p>\n<h2>Automatic Garbage Collection</h2>\n<p>Automatic garbage collection is the process of looking at heap memory, identifying which objects are in use and deleting the unused objects. An in-use object, means that some part of your program still maintains a pointer to that object. An unused object, or unreferenced object, is no longer referenced by any part of your program. So the memory used by an unreferenced object can be reclaimed.</p>\n<p>In a programming language like C++, allocating and deallocating memory is a manual process. In other languages e.g. .net and Java, the process of deallocating memory is handled automatically by the garbage collector.</p>\n<h3>Basic Process</h3>\n<h4>Marking</h4>\n<p>The first step in the process is called marking. This is the activity of marking what parts of memory have references and which have not.</p>\n<h4>Deletion</h4>\n<p>The second part is removing unreferenced objects, The deletion can be normal or can also include compacting.</p>\n<h3>Stop the world</h3>\n<p>When a gc happens all the threads in the application are stopped in what is referenced to as a “Stop the world” event.</p>\n<h2>JVM Generations</h2>\n<p>Having to mark and compact all objects in the JVM is inefficient, as more and more objects are allocated the list of objects grows and grows leading to a longer GC time. Empirical analysis of applications has shown that most objects are short lived.</p>\n<h3>Generations</h3>\n<p>The Hotspot JDK is broken into the following generations.</p>\n<ul>\n<li>Young</li>\n<li>Old</li>\n<li>Permanent</li>\n</ul>\n<p><img src=\"/images/./image.axd?picture=image_thumb_284.png\" alt=\"\"></p>\n<p>Note not all JDK’s have the same structure<img src=\"./image.axd?picture=image_thumb_285.png\" alt=\"image\"></p>\n<p><em>In this post I’m referring the the SUN JDK6 only. I’ve not really used the JDK7 that much except for personal projects, but even that is different with the G1 (Garbage First) and JDK8 will be a game changer again…</em></p>\n<h3>Sun Hotspot</h3>\n<p>The <strong>Young Generation</strong> is where all new objects are allocated and aged. When the young generation fills up, this causes a <strong><em>minor garbage collection</em></strong>. Minor collections can be optimized assuming a high object mortality rate. A young generation full of dead objects is collected very quickly. Some surviving objects are aged and eventually move to the old generation.</p>\n<p>The <strong>Old Generation</strong> is used to store long surviving objects. Typically, a threshold is set for young generation object and when that age is met, the object gets moved to the old generation. Eventually the old generation needs to be collected. This event is called a <strong><em>major garbage collection</em></strong>.</p>\n<p>The <strong>Permanent generation</strong> contains metadata required by the JVM to describe the classes and methods used in the application. The permanent generation is populated by the JVM at runtime based on classes in use by the application. In addition, Java SE library classes and methods may be stored here.</p>\n<p>Classes may get collected (unloaded) if the JVM finds they are no longer needed and space may be needed for other classes. The permanent generation is included in a full garbage collection.</p>\n<h2>GC Process</h2>\n<p>In the simplest of terms:</p>\n<ul>\n<li>New objects are allocated into the eden section of the heap. after the first GC if they are still referenced they are aged and moved to the S0.</li>\n<li>On the next GC, any referenced objects in eden are moved into S1, also the objects in S0 if still referenced are aged and also moved to S1.</li>\n<li>The process repeats alternating between S0 and S1 until the objects are aged enough to become eligible for the old age pension and are promoted into the tentured generation.</li>\n</ul>\n<h2>Show me the memory!</h2>\n<p>So enough talking, show me the money as Cuba Gooding once said ;-)</p>\n<p>The simplest way to visualize the GC in operation is to open the %JAVA_HOME%\\bin\\jvisualvm</p>\n<p>When you run it for the first time it will ask you to click OK to calibrate so do this.</p>\n<p>You will need to go to Tools/Plugins/Available Plugins and choose VisualGC (i’ve it already installed hence you see in a different tab)</p>\n<p><img src=\"/images/./image.axd?picture=image_thumb_275.png\" alt=\"\"></p>\n<p>You can then double click on the java application you wish to profile (I chose Weblogic Application Server) and you can see the GC minor collections in progress.</p>\n<p>Shows the WLS server starting up and the Eden space starting to fill.<img src=\"/images/./image.axd?picture=image_thumb_276.png\" alt=\"\"></p>\n<p>Shows the Survivor<img src=\"/images/./image.axd?picture=image_thumb_277.png\" alt=\"\"> 1 getting the first aged references</p>\n<p>S<img src=\"/images/./image.axd?picture=image_thumb_278.png\" alt=\"\">hows the minor GC’s and the alternating between S0 and S1</p>\n<p>Shows aged survivors getting their old age pension<img src=\"/images/./image.axd?picture=image_thumb_283.png\" alt=\"\"></p>\n<p>You can look at the monitor tab to get some more diagnostics,<br>\nNumber of threads / Classes etc</p>\n<p><img src=\"/images/./image.axd?picture=image_thumb_280.png\" alt=\"\"> You can see what types of objects are holding memory<img src=\"/images/./image.axd?picture=image_thumb_281.png\" alt=\"\"></p>\n<h2>NewRelic</h2>\n<p>Another tool I recommend when instrumenting applications is NewRelic.com not only will you get JVM stats, but you’ll get so, so, so, sooo much more, you just have to use it to believe it.</p>","frontmatter":{"title":"Garbage Collection in the JVM (1.6)","date":"November 07, 2013"}}},"pageContext":{"slug":"/blog/2013-11-07-garbage-collection-in-the-jvm-1-6-/"}},"staticQueryHashes":["2326376460","63159454"],"slicesMap":{}}