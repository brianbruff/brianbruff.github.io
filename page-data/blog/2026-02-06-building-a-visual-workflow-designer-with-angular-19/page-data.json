{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/2026-02-06-building-a-visual-workflow-designer-with-angular-19/","result":{"data":{"markdownRemark":{"html":"<p>I recently built a visual workflow designer — a node-based canvas where you wire together processing steps to compose data pipelines. It's the kind of tool you see in platforms like Node-RED, Apache NiFi, or n8n, but built from scratch with Angular 19 and a handful of well-chosen libraries. You can <a href=\"https://briankeating.net/flow-design-canvas/\" target=\"_blank\">try it live here</a>.</p>\n<p>In this post I'll walk through the architectural decisions, the Angular 19 features that made it enjoyable to build, and the patterns I'd use again.</p>\n<p><img src=\"/images/flow-design-canvas-properties.png\" alt=\"Flow Design Canvas — workflow with properties panel open\"></p>\n<h2>The Problem Space</h2>\n<p>Workflow designers need to solve several interrelated problems at once: rendering an interactive canvas with pan and zoom, managing a graph of connected nodes, keeping node configuration in sync with the visual state, and doing all of it with an experience that feels immediate. The challenge isn't any single piece — it's holding them all together cleanly.</p>\n<h2>Technology Choices</h2>\n<h3>ngx-vflow for the Canvas</h3>\n<p>The biggest decision was how to handle the canvas. Building a custom pan-zoom-drag-connect canvas from scratch is weeks of work and a maintenance burden. I chose <a href=\"https://www.ngx-vflow.com/\" target=\"_blank\">ngx-vflow</a>, a purpose-built Angular library for flow diagrams. It handles:</p>\n<ul>\n<li>Node rendering with custom HTML templates</li>\n<li>Edge drawing with bezier curves</li>\n<li>Pan, zoom, and minimap</li>\n<li>Snap-to-grid</li>\n<li>Connection validation</li>\n</ul>\n<p>This let me focus on the domain — the workflow nodes, their configuration, and how they relate — rather than fighting with pointer events and SVG paths.</p>\n<h3>Angular Material for Forms</h3>\n<p>Each node type needs its own configuration form (URL and auth settings for HTTP requests, prompt and model for AI assistants, table and batch size for database loads). Angular Material's form field components gave me a consistent dark-theme UI with minimal effort. Combined with Reactive Forms, the property editing experience came together quickly.</p>\n<h3>Signals over NgRx</h3>\n<p>This was the most deliberate choice. Traditional Angular state management with NgRx or similar libraries would have added boilerplate for what is fundamentally a simple data flow: a list of nodes, a list of edges, and which node is selected. Angular 19's signals handle this perfectly.</p>\n<h2>Architecture Overview</h2>\n<p>The application follows a three-column layout — node palette on the left, canvas in the centre, and a properties panel on the right that appears when a node is selected.</p>\n<p><img src=\"/images/flow-design-canvas-architecture.png\" alt=\"Architecture diagram showing how services feed into components\"></p>\n<p>Three services manage the state:</p>\n<ul>\n<li><strong>WorkflowService</strong> — owns the nodes and edges as signals, handles selection</li>\n<li><strong>NodeRegistryService</strong> — a factory and registry for the seven node types</li>\n<li><strong>CanvasInteractionService</strong> — UI state like zoom level, snap-to-grid toggle, and minimap visibility</li>\n</ul>\n<h2>Signal-Based State Management</h2>\n<p>The core of the application is <code class=\"language-text\">WorkflowService</code>, and it's remarkably small — about 80 lines. The state is three signals and a computed value:</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token decorator\"><span class=\"token at operator\">@</span><span class=\"token function\">Injectable</span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> providedIn<span class=\"token operator\">:</span> <span class=\"token string\">'root'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">WorkflowService</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">readonly</span> nodes <span class=\"token operator\">=</span> <span class=\"token generic-function\"><span class=\"token function\">signal</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>WorkflowNode<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">readonly</span> edges <span class=\"token operator\">=</span> <span class=\"token generic-function\"><span class=\"token function\">signal</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>WorkflowEdge<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">readonly</span> selectedNodeId <span class=\"token operator\">=</span> <span class=\"token generic-function\"><span class=\"token function\">signal</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">readonly</span> selectedNode <span class=\"token operator\">=</span> <span class=\"token function\">computed</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> id <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">selectedNodeId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">nodes</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> n<span class=\"token punctuation\">.</span>id <span class=\"token operator\">===</span> id<span class=\"token punctuation\">)</span> <span class=\"token operator\">??</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Updates are immutable — <code class=\"language-text\">nodes.update(ns => [...ns, newNode])</code> — which keeps change detection predictable and debugging straightforward. The <code class=\"language-text\">selectedNode</code> computed signal means the properties panel reactively shows the right form without any subscription management.</p>\n<h2>The Node Type System</h2>\n<p>I wanted adding a new node type to be a matter of defining three things: a registration entry (icon, label, category, default properties), a TypeScript interface for its properties, and a form component. The type system enforces this with a discriminated union:</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">NodeProperties</span> <span class=\"token operator\">=</span>\n  <span class=\"token operator\">|</span> HttpRequestProperties\n  <span class=\"token operator\">|</span> FtpDownloadProperties\n  <span class=\"token operator\">|</span> ExcelMapperProperties\n  <span class=\"token operator\">|</span> PdfMapperProperties\n  <span class=\"token operator\">|</span> TransformerProperties\n  <span class=\"token operator\">|</span> AiAssistantProperties\n  <span class=\"token operator\">|</span> DbLoadProperties<span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>The <code class=\"language-text\">NodeRegistryService</code> maps each <code class=\"language-text\">NodeType</code> enum value to its metadata and acts as a factory for creating node instances with unique IDs, default properties, and port definitions.</p>\n<p>Seven node types ship today across three categories:</p>\n<table>\n<thead>\n<tr>\n<th>Category</th>\n<th>Nodes</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Input</strong></td>\n<td>HTTP Request, FTP Download</td>\n</tr>\n<tr>\n<td><strong>Processor</strong></td>\n<td>Excel Mapper, PDF Mapper, Transformer, AI Assistant</td>\n</tr>\n<tr>\n<td><strong>Output</strong></td>\n<td>Database Load</td>\n</tr>\n</tbody>\n</table>\n<h2>Bridging Signals and ngx-vflow</h2>\n<p>The trickiest piece was the <code class=\"language-text\">CanvasShellComponent</code>. ngx-vflow manages its own internal state with signals — each node has position, data, and selection signals. My <code class=\"language-text\">WorkflowService</code> also uses signals. Keeping these two signal worlds in sync required a reconciliation strategy.</p>\n<p>I maintain a <code class=\"language-text\">Map&lt;string, VflowNodeEntry></code> that caches the per-node signals ngx-vflow needs. An <code class=\"language-text\">effect()</code> watches the domain nodes and reconciles:</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">readonly</span> reconcileEffect <span class=\"token operator\">=</span> <span class=\"token function\">effect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> domainNodes <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>workflowService<span class=\"token punctuation\">.</span><span class=\"token function\">nodes</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// For each domain node:</span>\n  <span class=\"token comment\">//   - If new: create vflow signals and add to map</span>\n  <span class=\"token comment\">//   - If existing: update the signals in place</span>\n  <span class=\"token comment\">//   - If removed: delete from map</span>\n  <span class=\"token comment\">// Then rebuild the vflowNodes signal array</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>This avoids recreating signals every cycle, which would break ngx-vflow's internal change tracking. It's a pattern I'd reach for any time you need to bridge two signal-based systems.</p>\n<h2>Dynamic Properties Panel</h2>\n<p>When you select a node, the properties panel renders the correct form using Angular 19's <code class=\"language-text\">@switch</code> control flow:</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\">@<span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span>nodeType<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  @<span class=\"token keyword\">case</span> <span class=\"token punctuation\">(</span>NodeType<span class=\"token punctuation\">.</span>HttpRequest<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token operator\">&lt;</span>app<span class=\"token operator\">-</span>http<span class=\"token operator\">-</span>request<span class=\"token operator\">-</span>form\n      <span class=\"token punctuation\">[</span>properties<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span><span class=\"token string\">\"$any(node.data.properties)\"</span>\n      <span class=\"token punctuation\">(</span>propertiesChange<span class=\"token punctuation\">)</span><span class=\"token operator\">=</span><span class=\"token string\">\"onPropertiesChange($event)\"</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n  <span class=\"token punctuation\">}</span>\n  @<span class=\"token keyword\">case</span> <span class=\"token punctuation\">(</span>NodeType<span class=\"token punctuation\">.</span>AiAssistant<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token operator\">&lt;</span>app<span class=\"token operator\">-</span>ai<span class=\"token operator\">-</span>assistant<span class=\"token operator\">-</span>form\n      <span class=\"token punctuation\">[</span>properties<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span><span class=\"token string\">\"$any(node.data.properties)\"</span>\n      <span class=\"token punctuation\">(</span>propertiesChange<span class=\"token punctuation\">)</span><span class=\"token operator\">=</span><span class=\"token string\">\"onPropertiesChange($event)\"</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// ... five more cases</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Each form component follows the same contract: a <code class=\"language-text\">properties</code> input, a <code class=\"language-text\">propertiesChange</code> output, and internally a reactive form with 300ms debouncing to avoid flooding the workflow service with updates on every keystroke.</p>\n<p><img src=\"/images/flow-design-canvas-overview.png\" alt=\"Flow Design Canvas — nodes connected with minimap visible\"></p>\n<h2>Angular 19 Features Worth Highlighting</h2>\n<p>A few Angular 19 features made this project noticeably smoother than it would have been even a year ago:</p>\n<p><strong>Standalone components everywhere.</strong> No <code class=\"language-text\">NgModule</code> declarations, no shared modules. Every component imports exactly what it needs. The mental overhead of module boundaries is just gone.</p>\n<p><strong>Built-in control flow.</strong> <code class=\"language-text\">@if</code>, <code class=\"language-text\">@for</code>, and <code class=\"language-text\">@switch</code> replace structural directives. They're faster (better tree-shaking), and the template reads more naturally — especially the <code class=\"language-text\">@switch</code> block for the properties panel.</p>\n<p><strong>Signals and computed values.</strong> The entire state layer is signals. No <code class=\"language-text\">BehaviorSubject</code>, no <code class=\"language-text\">async</code> pipe, no subscription cleanup. The <code class=\"language-text\">computed()</code> for derived state and <code class=\"language-text\">effect()</code> for side effects cover everything I needed.</p>\n<p><strong>Event coalescing.</strong> A single line in the app config — <code class=\"language-text\">provideZoneChangeDetection({ eventCoalescing: true })</code> — batches change detection for canvas interactions where many events fire in rapid succession.</p>\n<h2>Theming with CSS Custom Properties</h2>\n<p>The dark theme uses CSS custom properties for every colour, with each node type getting its own accent:</p>\n<div class=\"gatsby-highlight\" data-language=\"scss\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-scss line-numbers\"><code class=\"language-scss\"><span class=\"token selector\">:root </span><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">--node-color-http-request</span><span class=\"token punctuation\">:</span> #00a8ff<span class=\"token punctuation\">;</span>\n  <span class=\"token property\">--node-color-ftp-download</span><span class=\"token punctuation\">:</span> #ff7d00<span class=\"token punctuation\">;</span>\n  <span class=\"token property\">--node-color-excel-mapper</span><span class=\"token punctuation\">:</span> #39b84a<span class=\"token punctuation\">;</span>\n  <span class=\"token property\">--node-color-pdf-mapper</span><span class=\"token punctuation\">:</span> <span class=\"token function\">rgb</span><span class=\"token punctuation\">(</span>251<span class=\"token punctuation\">,</span> 75<span class=\"token punctuation\">,</span> 75<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token property\">--node-color-transformer</span><span class=\"token punctuation\">:</span> #d986ff<span class=\"token punctuation\">;</span>\n  <span class=\"token property\">--node-color-ai-assistant</span><span class=\"token punctuation\">:</span> #f5b800<span class=\"token punctuation\">;</span>\n  <span class=\"token property\">--node-color-db-load</span><span class=\"token punctuation\">:</span> #26c6da<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Each node renders a coloured stripe on the left edge using its accent colour. It's a small touch, but it makes the canvas scannable at a glance — you can immediately tell your inputs from your processors from your outputs.</p>\n<h2>What I'd Do Differently</h2>\n<p><strong>Drag-from-palette.</strong> Currently, clicking a node in the palette adds it to the canvas at an auto-calculated position. True drag-and-drop from the palette to the canvas would feel more natural. ngx-vflow supports this; I just haven't wired it up yet.</p>\n<p><strong>Undo/redo.</strong> With immutable signal updates, implementing undo is straightforward — snapshot the signals on each mutation and replay. It's the next feature I'd add.</p>\n<p><strong>Persisting workflows.</strong> The node and edge arrays serialise cleanly to JSON. Adding localStorage or a backend save endpoint would make this actually useful beyond a demo.</p>\n<h2>Try It</h2>\n<p>The app is deployed to GitHub Pages and the source is on GitHub:</p>\n<ul>\n<li><strong>Live demo:</strong> <a href=\"https://briankeating.net/flow-design-canvas/\" target=\"_blank\">briankeating.net/flow-design-canvas</a></li>\n<li><strong>Source:</strong> <a href=\"https://github.com/brianbruff/flow-design-canvas\" target=\"_blank\">github.com/brianbruff/flow-design-canvas</a></li>\n</ul>\n<p>It's a single <code class=\"language-text\">ng build</code> with no server requirements. If you're exploring Angular 19's signal-based patterns or looking for a starting point for a visual editor, take a look.</p>","frontmatter":{"title":"Building a Visual Workflow Designer with Angular 19","date":"February 06, 2026"}}},"pageContext":{"slug":"/blog/2026-02-06-building-a-visual-workflow-designer-with-angular-19/"}},"staticQueryHashes":["2326376460","63159454"],"slicesMap":{}}