{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/2011-08-24-async-workflows-in-asp-net/","result":{"data":{"markdownRemark":{"html":"<p>So tonight I’m going to show you one way on calling async workflows from ASP.net. I’ve decided to use web forms this time as I’m living in MVC land and it’ll help me keep the finger in.</p>\n<p>So lets take a look at the app we’re trying to build</p>\n<p>Client is a simple web form, the instruments are entered in the text box, fetch button is clicked and the result is output</p>\n<p><img src=\"/images/./image.axd?picture=image_thumb_83.png\" alt=\"\"></p>\n<p>Now the workflow, for the purpose of this test I won’t be connecting to any database webservice etc, I’ve just added a delay of 10 seconds and and assign the value of LastClose to</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">RIC &amp; \" \" &amp; New Random().NextDouble()</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p><img src=\"/images/./image.axd?picture=image_thumb_84.png\" alt=\"\"></p>\n<p>Here’s the code behind for the <strong>non-async</strong> button event handler</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">        protected void Button1_Click(object sender, EventArgs e)\n\n        {\n\n            Contract.Requires(!string.IsNullOrWhiteSpace(tbInst1.Text) || !string.IsNullOrWhiteSpace(tbInst2.Text), \"Please enter values for instruments\");\n\n            // Make the call to the workflow to get the close for each instrument\n\n            try\n\n            {\n\n                var args = new Dictionary&lt;string, object>();\n\n                args.Add(\"RIC\", tbInst1.Text);                \n\n                var res = WorkflowInvoker.Invoke(_getPricesWFDefinition, args);\n\n                Label1.Text = res[\"LastClose\"].ToString();\n\n                args.Clear();\n\n                args.Add(\"RIC\", tbInst2.Text);\n\n                res = WorkflowInvoker.Invoke(_getPricesWFDefinition, args);\n\n                Label2.Text = res[\"LastClose\"].ToString();\n\n            }\n\n            catch (Exception exp)\n\n            {\n\n                Trace.Warn(exp.Message);\n\n            }\n\n        }</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>So as you can see, we’re waiting at least 20 seconds for our page to return, nasty. In theory we should be able to bring this down to 10 seconds as we can make the calls to the workflows async.</p>\n<p>Let me show you some options.</p>\n<h2>Option 1</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">        private void Option1()\n\n        {\n\n            var t1 = Option1TaskCreater(tbInst1, Label1);\n\n            var t2 = Option1TaskCreater(tbInst2, Label2);\n\n            Task.WaitAll(t1, t2);\n\n        }\n\n        private Task Option1TaskCreater(TextBox tb, Label lb)\n\n        {\n\n            var t1 = Task.Factory.StartNew(() =>\n\n            {\n\n                var args = new Dictionary&lt;string, object>();\n\n                args.Add(\"RIC\", tb.Text);\n\n                var res = WorkflowInvoker.Invoke(_getPricesWFDefinition, args);\n\n                lb.Text = res[\"LastClose\"].ToString();\n\n            });\n\n            return t1;\n\n        } </code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>So we’re using the task library to make the two workflow requests async, and results look promising, down to about 10 seconds now… so any problems with doing this?</p>\n<p>Well, tasks use threadpool threads to execute. So, the query will execute on a threadpool thread. To get true asynchronous execution(no worker threads blocked), we need to jump a little higher.</p>\n<p>You may ask yourself when should you choose an asynchronous programming model (APM)?</p>\n<p><img src=\"/images/./image.axd?picture=image_thumb_85.png\" alt=\"\"></p>\n<p>So what is this telling us? Basically, if your app is I/O bound then you should use parallelism, if requests are computationally cheap to process, then parallelism is probably an unnecessary overhead.</p>\n<p>If the incoming request rate is high, then adding more parallelism will likely yield few benefits and could actually decrease performance, since the incoming rate of work may be high enough to keep the CPUs busy.</p>\n<p>If the incoming request rate is low, then the Web application could benefit from parallelism by using the idle CPU cycles to speed up the processing of an individual request. We can use either PLINQ or TPL (either Parallel loops or the Task class) to parallelize the computation over all the processors. Note that by default, however, the PLINQ implementation in .NET 4 will tie-up one ThreadPool worker per processor for the entire execution of the query. As such, it should only be used in Web applications that see few but expensive requests.</p>","frontmatter":{"title":"Async Workflows in ASP.net","date":"August 24, 2011"}}},"pageContext":{"slug":"/blog/2011-08-24-async-workflows-in-asp-net/"}},"staticQueryHashes":["2326376460","63159454"],"slicesMap":{}}