{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/2019-05-01-flexing-those-java-generic-pecs/","result":{"data":{"markdownRemark":{"html":"<p>I believe I’ve previously covered c# generics covariance and contravariance in the past, now it’s javas turn</p>\n<p>As you may or may not know</p>\n<p>The term PECS stands for “Producer Extends, Consumer Super,” which is an odd acronym coined by Joshua Block in his Effective Java book, but provides a mnemonic on what to do. It means that if a parameterized type represents a producer, use extends. If it represents a consumer, use super. If the parameter is both, don’t use wildcards at all—the only type that satisfies both requirements is the explicit type itself.</p>\n<p>Covariance in java uses the extends keyword (yes even with interfaces), e.g. List accommodates all types that derive from Number</p>\n<p>Contravariance on the other hand uses the super keyword e.g. List accommodates all the types that Number derives from and of course number itself.</p>\n<p>So what exactly is PECS recommending we do?</p>\n<ul>\n<li>Use extends when you only get values out of a data structure</li>\n<li>Use super when you only put values into a data structure</li>\n<li>Use the exact type when you plan on doing both</li>\n</ul>","frontmatter":{"title":"Flexing those Java generic PECS","date":"May 01, 2019"}}},"pageContext":{"slug":"/blog/2019-05-01-flexing-those-java-generic-pecs/"}},"staticQueryHashes":["2326376460","63159454"],"slicesMap":{}}