{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/2011-01-17-thread-starvation-in-mvc/","result":{"data":{"markdownRemark":{"html":"<p>On IIS, the .NET Framework maintains a pool of threads that are used to service ASP.NET requests. When a request arrives, a thread from the pool is dispatched to process that request. If the request is processed synchronously, the thread that processes the request is blocked while the request is being processed, and that thread cannot service another request.</p>\n<p>This is generally not a problem insofar as ASP.net may have enough threads (depending on version) to accommodate a few blocked threads, however when all threads are blocked you’ll see a 503 http error presented – now in thread starvation.</p>\n<p>Firstly, lets talk about standard asp.NET, how can we overcome this problem?</p>\n<p>Seasoned .NET developers may attempt to begin invoke on a delegate (using lambdas these days <img src=\"/blog/image.axd?picture=wlEmoticon-hotsmile_1.png\" alt=\"Hot smile\">) or use the ThreadPool.QueueUserWorkItem, however both these approaches are futile as the both draw from the same thread pool as asp.NET <img src=\"/blog/image.axd?picture=wlEmoticon-confusedsmile.png\" alt=\"Confused smile\"></p>\n<p>Another naïve approach would be to serve up your own thread, think about this for a second, your website is there to handle multiple requests…! Needless to say it could promptly run out of resources as a new thread would be created for each request.</p>\n<p>The asp.NET solution is to use async pages , &#x3C;%@ Page Async=”true” …> / Page.AddOnPreRenderCompleteAsync</p>\n<p>So what about mvc?</p>\n<h1>MVC – Async Actions</h1>\n<p><img src=\"/images//blog/image.axd?picture=clip_image001_thumb.png\" alt=\"\"></p>\n<ol>\n<li>\n<p>The Web server gets a thread from the thread pool (the worker thread) and schedules it to handle an incoming request. This worker thread initiates an asynchronous operation.</p>\n</li>\n<li>\n<p>The worker thread is returned to the thread pool to service another Web request.</p>\n</li>\n<li>\n<p>When the asynchronous operation is complete, it notifies ASP.NET.</p>\n</li>\n<li>\n<p>The Web server gets a worker thread from the thread pool (which might be a different thread from the thread that started the asynchronous operation) to process the remainder of the request, including rendering the response.</p>\n</li>\n</ol>\n<p>SYNC</p>\n<p>public class PortalController: Controller {<br>\npublic ActionResult News(string city) {<br>\nNewsService newsService = new NewsService();<br>\nViewStringModel headlines = newsService.GetHeadlines(city);<br>\nreturn View(headlines);<br>\n}<br>\n}</p>\n<p>ASYNC</p>\n<p>public class PortalController : AsyncController {<br>\npublic void NewsAsync(string city) {</p>\n<p>AsyncManager.OutstandingOperations.Increment();<br>\nNewsService newsService = new NewsService();<br>\nnewsService.GetHeadlinesCompleted += (sender, e) =><br>\n{<br>\nAsyncManager.Parameters[\"headlines\"] = e.Value;<br>\nAsyncManager.OutstandingOperations.Decrement();<br>\n};<br>\nnewsService.GetHeadlinesAsync(city);<br>\n}</p>\n<p>public ActionResult NewsCompleted(string[] headlines) {<br>\nreturn View(\"News\", new ViewStringModel<br>\n{<br>\nNewsHeadlines = headlines<br>\n});<br>\n}<br>\n}</p>\n<p>Note:</p>\n<ol>\n<li>New derivation</li>\n<li>Matching Async/Completed calls</li>\n</ol>","frontmatter":{"title":"Thread starvation in MVC","date":"January 17, 2011"}}},"pageContext":{"slug":"/blog/2011-01-17-thread-starvation-in-mvc/"}},"staticQueryHashes":["2326376460","63159454"],"slicesMap":{}}